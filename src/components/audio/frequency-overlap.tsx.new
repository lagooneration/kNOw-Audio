import { useEffect, useRef } from 'react';
import { type AudioData } from '../../types/audio';
import { type FrequencyOverlap } from '../../utils/audio-mixing';

interface FrequencyOverlapVisualizerProps {
  track1: AudioData;
  track2: AudioData;
  overlaps: FrequencyOverlap[];
  height?: number;
  width?: number;
}

export function FrequencyOverlapVisualizer({
  track1,
  track2,
  overlaps,
  height = 300,
  width = 800
}: FrequencyOverlapVisualizerProps) {
  const canvasRef = useRef<HTMLCanvasElement>(null);
  
  useEffect(() => {
    if (!canvasRef.current || !track1 || !track2) return;
    
    const canvas = canvasRef.current;
    const ctx = canvas.getContext('2d');
    if (!ctx) return;
    
    // Clear canvas
    ctx.clearRect(0, 0, width, height);
    
    // Set background
    ctx.fillStyle = '#0d1117';
    ctx.fillRect(0, 0, width, height);
    
    // Draw grid
    ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
    ctx.lineWidth = 1;
    
    // Horizontal grid lines
    for (let i = 0; i <= 5; i++) {
      const y = (i / 5) * height;
      ctx.beginPath();
      ctx.moveTo(0, y);
      ctx.lineTo(width, y);
      ctx.stroke();
    }
    
    // Vertical grid lines (logarithmic for frequency)
    const freqLabels = [20, 50, 100, 200, 500, 1000, 2000, 5000, 10000, 20000];
    freqLabels.forEach(freq => {
      const x = getXForFrequency(freq, width);
      ctx.beginPath();
      ctx.moveTo(x, 0);
      ctx.lineTo(x, height);
      ctx.stroke();
    });
    
    // Draw frequency bands
    const frequencyBands = [
      { name: "Sub Bass", min: 20, max: 60 },
      { name: "Bass", min: 60, max: 250 },
      { name: "Low Mids", min: 250, max: 500 },
      { name: "Mids", min: 500, max: 2000 },
      { name: "High Mids", min: 2000, max: 4000 },
      { name: "Presence", min: 4000, max: 6000 },
      { name: "Brilliance", min: 6000, max: 20000 }
    ];
    
    // Draw frequency band separators and labels
    ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
    ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
    ctx.font = '10px Arial';
    ctx.textAlign = 'center';
    
    frequencyBands.forEach(band => {
      const x1 = getXForFrequency(band.min, width);
      const x2 = getXForFrequency(band.max, width);
      
      // Draw vertical line at band boundary
      ctx.beginPath();
      ctx.moveTo(x1, 0);
      ctx.lineTo(x1, height);
      ctx.stroke();
      
      // Draw band label
      ctx.fillText(band.name, (x1 + x2) / 2, height - 5);
    });
    
    // Draw final boundary line
    const finalX = getXForFrequency(20000, width);
    ctx.beginPath();
    ctx.moveTo(finalX, 0);
    ctx.lineTo(finalX, height);
    ctx.stroke();
    
    // Simulate spectrum data for visualization
    // In a real implementation, you would use real frequency analysis data
    drawSimulatedSpectrum(ctx, track1, '#4169E1', 0.6, width, height);
    drawSimulatedSpectrum(ctx, track2, '#228B22', 0.6, width, height);
    
    // Highlight overlap regions
    overlaps.forEach(overlap => {
      // Calculate position using logarithmic scale
      const x = getXForFrequency(overlap.frequency, width);
      
      // Determine color and opacity based on constructive/destructive nature and intensity
      // Use higher opacity for stronger overlaps
      const baseOpacity = 0.3 + (overlap.overlapIntensity * 0.7);
      
      const color = overlap.isConstructive 
        ? `rgba(255, 165, 0, ${baseOpacity})` // Orange for constructive
        : `rgba(255, 0, 0, ${baseOpacity})`; // Red for destructive
      
      // Calculate band width
      const minFreq = overlap.frequency * 0.8;
      const maxFreq = overlap.frequency * 1.2;
      const x1 = getXForFrequency(minFreq, width);
      const x2 = getXForFrequency(maxFreq, width);
      const bandWidth = x2 - x1;
      
      // Draw vertical highlight for the overlap
      ctx.fillStyle = color;
      ctx.fillRect(
        x - bandWidth / 2, 
        0, 
        bandWidth, 
        height
      );
      
      // Add a border to make it more visible
      ctx.strokeStyle = overlap.isConstructive ? 'rgba(255, 200, 100, 0.9)' : 'rgba(255, 100, 100, 0.9)';
      ctx.lineWidth = 1;
      ctx.strokeRect(
        x - bandWidth / 2, 
        0, 
        bandWidth, 
        height
      );
      
      // Add label for significant overlaps
      if (overlap.overlapIntensity > 0.6) {
        // Draw a background for the text to make it more readable
        const frequencyText = `${Math.round(overlap.frequency)}Hz`;
        const typeText = overlap.isConstructive ? 'Constructive' : 'Destructive';
        
        // Measure text width
        const freqTextWidth = ctx.measureText(frequencyText).width;
        const typeTextWidth = ctx.measureText(typeText).width;
        const maxWidth = Math.max(freqTextWidth, typeTextWidth);
        
        // Draw background for frequency text
        ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
        ctx.fillRect(x - maxWidth/2 - 5, height - 45, maxWidth + 10, 40);
        
        // Draw text
        ctx.fillStyle = 'white';
        ctx.font = '10px Arial';
        ctx.textAlign = 'center';
        ctx.fillText(
          frequencyText, 
          x, 
          height - 30
        );
        
        // Add constructive/destructive label
        ctx.fillStyle = overlap.isConstructive ? 'rgba(255, 200, 100, 1)' : 'rgba(255, 100, 100, 1)';
        ctx.fillText(
          typeText,
          x,
          height - 15
        );
      }
    });
    
    // Add frequency labels on x-axis
    ctx.fillStyle = 'white';
    ctx.font = '12px Arial';
    ctx.textAlign = 'center';
    
    freqLabels.forEach(freq => {
      const x = getXForFrequency(freq, width);
      ctx.fillText(`${freq < 1000 ? freq : (freq/1000)+'k'}`, x, height - 25);
    });
    
    // Add legend
    ctx.fillStyle = 'rgba(65, 105, 225, 0.6)';
    ctx.fillRect(width - 150, 10, 20, 10);
    ctx.fillStyle = 'white';
    ctx.textAlign = 'left';
    ctx.fillText(`Track 1: ${track1.metadata.name}`, width - 125, 20);
    
    ctx.fillStyle = 'rgba(34, 139, 34, 0.6)';
    ctx.fillRect(width - 150, 30, 20, 10);
    ctx.fillStyle = 'white';
    ctx.fillText(`Track 2: ${track2.metadata.name}`, width - 125, 40);
    
    ctx.fillStyle = 'rgba(255, 165, 0, 0.6)';
    ctx.fillRect(width - 150, 50, 20, 10);
    ctx.fillStyle = 'white';
    ctx.fillText('Constructive Overlap', width - 125, 60);
    
    ctx.fillStyle = 'rgba(255, 0, 0, 0.6)';
    ctx.fillRect(width - 150, 70, 20, 10);
    ctx.fillStyle = 'white';
    ctx.fillText('Destructive Overlap', width - 125, 80);
    
  }, [track1, track2, overlaps, height, width]);
  
  // Helper function to map frequency to x-coordinate using logarithmic scale
  function getXForFrequency(freq: number, width: number): number {
    const minFreq = 20;
    const maxFreq = 20000;
    const logMin = Math.log10(minFreq);
    const logMax = Math.log10(maxFreq);
    const logFreq = Math.log10(Math.max(minFreq, Math.min(maxFreq, freq)));
    
    return width * (logFreq - logMin) / (logMax - logMin);
  }
  
  // Helper function to draw simulated spectrum data
  function drawSimulatedSpectrum(
    ctx: CanvasRenderingContext2D, 
    track: AudioData, 
    color: string, 
    opacity: number,
    width: number,
    height: number
  ) {
    const points = 100;
    const alpha = `${opacity}`;
    ctx.strokeStyle = `rgba(${color.replace(/[^\d,]/g, '')}, ${alpha})`;
    ctx.lineWidth = 2;
    ctx.beginPath();
    
    // Use track name to generate a unique but consistent pattern
    const seed = track.metadata.name.split('').reduce((sum, char) => sum + char.charCodeAt(0), 0);
    
    for (let i = 0; i < points; i++) {
      const freq = 20 * Math.pow(10, i / (points - 1) * 3); // 20Hz to 20kHz logarithmically
      const x = getXForFrequency(freq, width);
      
      // Generate a value based on the frequency and track seed
      // This creates a unique spectrum shape for each track
      const normFreq = Math.log10(freq) / 3; // Normalize frequency to 0-1
      const value = 0.2 + // Base level
        0.3 * Math.sin(normFreq * 10 + seed * 0.1) + // General shape
        0.3 * Math.sin(normFreq * 20 + seed * 0.2) + // Fine structure
        0.2 * Math.sin(normFreq * 5 + seed * 0.3);   // Low frequency detail
      
      const y = height - value * height * 0.8;
      
      if (i === 0) {
        ctx.moveTo(x, y);
      } else {
        ctx.lineTo(x, y);
      }
    }
    
    ctx.stroke();
  }
  
  return (
    <canvas
      ref={canvasRef}
      width={width}
      height={height}
      className="w-full h-auto bg-background/50 rounded-md"
    />
  );
}
